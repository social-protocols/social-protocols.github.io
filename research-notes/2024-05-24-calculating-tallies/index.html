<!doctype html><html lang=en-us><head><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="Calculation of Informed and Uninformed Tallies Background: Effects One of the most important concepts in the GlobalBrain algorithm is the &ldquo;effect&rdquo; of a reply on a target. We use the term &ldquo;target&rdquo; to refer to the post being affected."><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.131.0"><title>- Social Protocols</title>
<meta property="og:title" content=" - Social Protocols"><link rel=stylesheet href=/css/fonts.css media=all><link rel=stylesheet href=/css/main.css media=all><script data-goatcounter=https://socialprotocols.goatcounter.com/count async src=//gc.zgo.at/count.js></script></head><body><div class=wrapper><header class=header><nav class=nav><a href=/ class=nav-logo style=margin-right:10px><img src=/images/logo.svg width=50 height=50 alt=Logo>
</a><a href=/ class=nav-title>Social Protocols</a><ul class=nav-links><li><a href=/articles>Articles</a></li><li><a href=/#projects>Projects</a></li><li><a href=/research-notes>Research Notes</a></li><li><a href=/resources>Resources</a></li></ul></nav></header><main class=content role=main><article class=article><h1 class=article-title></h1><div class=article-content><h1 id=calculation-of-informed-and-uninformed-tallies>Calculation of Informed and Uninformed Tallies</h1><h2 id=background-effects>Background: Effects</h2><p>One of the most important concepts in the GlobalBrain algorithm is the &ldquo;effect&rdquo; of a reply on a target. We use the term &ldquo;target&rdquo; to refer to the post being affected. A reply may be any reply in the reply tree for the target. The effect is how much more or likely users are to upvote the target (given they vote on it) given they have &ldquo;considered&rdquo; the reply.</p><h3 id=definition-of-consideration>Definition of Consideration</h3><p>There are (at least theoretically) different ways that users can be informed.
Our originally idea was that we consider a vote to be informed if the note
was shown below the post at the time the user voted on the post. But as
discussed in [this research note]
(<a href=https://github.com/social-protocols/internal-wiki/blob/main/pages/research-notes/2024-02-06-informed-probability.md)>https://github.com/social-protocols/internal-wiki/blob/main/pages/research-notes/2024-02-06-informed-probability.md)</a>,
the fact of actually voting on a note is probably a better for proxy for
whether the user has actually <strong>considered</strong> the note, which is really what
we care about when talking about users being &ldquo;informed&rdquo;.</p><h3 id=defining-effects>Defining Effects</h3><p>To compute effects, we start by computing two vote tallies. First, the <strong>informed tally</strong> is the count of upvotes/downvotes among users who have considered the reply. Second, the <strong>uninformed tally</strong> is the count for users who have not considered the reply.</p><h3 id=definition-of-informed-tally>Definition of Informed Tally</h3><p>Defining the informed tally is fairly straightforward. We include the (latest) votes of users who have considered a reply in the informed tally. We say that a user has &ldquo;considered&rdquo; a reply if they have voted on it.</p><p>However, there are some nuanced rules to the way we calculate the informed tally.</p><h4 id=rule-ordering-doesnt-matter>Rule: Ordering Doesn&rsquo;t Matter</h4><p>Whether the user votes on the target before or after voting on the reply, the
informed tally will always include their latest/final vote on the target, as
long as they have voted on the reply.</p><h4 id=rule-clearing-votes>Rule: Clearing Votes</h4><p>Since users can clear votes, users votes can become un-informed. The semantics
of voting and then clearing a vote should pretty much be the same as never
having voted. So both clearing a vote on the post and clearing a vote on the
note should result in the uninformed vote being cleared.</p><p>If the user clears their vote on the note but leaves their vote on the post,
their vote should become uninformed and be included in the uninformed tally.</p><h4 id=rule-implicit-consideration>Rule: Implicit Consideration</h4><p>We also say a user has considered a reply if they have voted on <em>any of its
descendants</em>. So for the thread A->B->C, if a user has voted on B, they have
implicitly considered B.</p><p>This further implies that user has considered a reply if they reply to it
(because their reply come with an automatic upvote).</p><h3 id=uninformed-tally>Uninformed Tally</h3><p>The users who have not considered a reply are counted in the uninformed tally.</p><h4 id=rule-uninformed-tally-includes-users-who-are-informed-of-parent>Rule: Uninformed Tally Includes Users who are Informed of Parent</h4><p>The first refinement to this rule is that, when computing the uninformed tally for a target/reply combination, we want to count users who have not voted on the reply, but have voted on the target, as well as <em>the parent of the reply</em>.</p><p>For example if we have thread A->B->C, the informed tally of target A and note C is includes the votes on A of users who are informed of B but not informed of C.</p><p>It is necessary to compute the uninformed tally this way because the algorithm calculates the effect of C on A by by first calculating the partially informed probability <em>r</em>, which is the probability that a user upvotes A given they have considered B but not yet C. This partially informed probability <em>r</em> is the prior for calculating the informed probability <em>p</em>. That is, we start by calculating the effect of B on A, and make the prior assumption that C has no <em>additional</em> effect on A, beyond the effect of B on A. We then update our posterior based on the votes of users who have also considered C.</p><p>In fact, what we are calling the uninformed tally should probably be renamed to partially-informed tally.</p><h4 id=rule-temporality>Rule: Temporality</h4><p>Defining the uninformed tally as the votes of users who have not considered the reply is ambiguous, because it doesn&rsquo;t take <strong>time</strong> into consideration. Do we mean the votes of users who have never considered the reply? Or the votes of users who had not considered the reply at the time they voted on the target?</p><h2 id=counting-methods>Counting Methods</h2><p>So even given these rules, there are different methods for calculating informed and uninformed tallies.</p><h3 id=method-1-no-temporality>Method 1: No Temporality</h3><p>The simplest method simply says that if a user has not (ever) voted on the reply, they are uninformed, and are thus counted in the uninformed tally. Otherwise, they are informed, and are thus counted in the informed tally.</p><h4 id=downside>Downside:</h4><p>But this means we can&rsquo;t capture the information in an actual &ldquo;changed mind&rdquo;. If a user sees a post, votes on it, then votes on the reply and also, being convinced by the reply, changes their vote on the post, we only count that user&rsquo;s final vote in the informed tally. We don&rsquo;t count their <em>previous</em>, uninformed vote in the uninformed tally.</p><p>In other words, by Method 1, a user&rsquo;s vote is only included in one tally, even if they change their vote after becoming informed.</p><h3 id=method-2-uninformed-vote-shapshot>Method 2: Uninformed Vote Shapshot</h3><p>To count the votes of users who have changed their minds in the uninformed tally, we can take a &ldquo;snapshot&rdquo; of the user&rsquo;s vote on the target at the time they become informed of the reply. For example, if they upvote target A, then vote on reply B, their uninformed vote on A is now an upvote, and this can no longer change. If they change their vote on A to a downvote, the uninformed vote remains an upvote. Any subsequent changes to their vote on A only changes their informed vote.</p><h4 id=downside-1>Downside:</h4><p>The problem here is that it makes the final tallies dependent on the order in which users depend to do things. This became clear in the simulations when we had many users all voting in the same way.</p><p>Suppose initially 100 users upvote A, but then are are convinced by reply B.
- If they first all change their vote on A from an upvote to a downvote, and then they all vote on B, the uninformed tally will include 100 <em>downvotes</em>.
- If they first vote on B, then change their vote on A from an upvote to a downvote, the uninformed tally will include 100 <em>upvotes</em>.</p><h3 id=method-3>Method 3</h3><p>This is similar to Method 2, but the uninformed snapshot is taken at the time the reply is posted. So the uninformed tally includes users who either:</p><ol><li>never voted on the reply</li><li>OR voted on the target <em>before</em> the reply was posted</li></ol><p>This solves the ordering problem of Method 2. To understand why, consider the example of the 100 users above. When using Method 3 to calculate the uninformed tally, there are two possible scenarios:</p><ul><li><p>Scenario 1. If the 100 users upvote A <em>before</em> B is posted. In this case, their initial upvotes are included in the uninformed tally. Thus we have:</p><ul><li>Informed Tally: 100 downvotes, 0 upvotes</li><li>Uninformed Tally: 0 downvotes, 100 upvotes</li></ul></li><li><p>Scenario 2. If the 100 users upvote A <em>after</em> B is posted, their initial upvotes are <em>not</em> included in the uninformed tally. Thus we have</p><ul><li>Informed Tally: 100 downvotes, 0 upvotes</li><li>Uninformed Tally: 0 downvotes, 0 upvotes</li></ul></li></ul><p>Note that Scenario 2, when using Method 3 has the same results as when using Method 1. Each user is only counted once, and we don&rsquo;t capture any uninformed votes. However, in the best case, if some users vote on A before B is posted, we also capture data about uninformed votes.</p><h4 id=downside-2>Downside</h4><p>The downside is that this is more complicated and confusing.</p><h3 id=which-method>Which Method?</h3><p>Method 2 isn&rsquo;t an option because of its sensitivity to vote order. Method 1 is the simplest and most intuitive, but captures less information. Method 3 is more complex but captures more information.</p><p>Is the additional information worth the complexity?</p><h4 id=argument-for-method-3-small-team-scenario>Argument for Method 3: Small Team Scenario</h4><p>Consider small teams where every user ultimately considers/votes on every reply. With Method 1, we can never measure if a vote actually changes minds &ndash; we lose information about the informativeness of reply. On the other hand, Method 3 will capture many common small-team scenarios.</p><p>For example, suppose there are only 2 users. The first user posts something, the second user downvotes the post and replies with a reason, and then the first user changes their vote.</p><p>With all methods, the informed tally will be 0:2 (0 upvotes, 2 downvotes). The informed probability will be small. Let&rsquo;s say, for example&rsquo;s sake, that it is p=30%.</p><p>With Method 1, the uninformed tally will be empty (0:0), since all users are informed. The uninformed probability will thus be equal to the prior. Suppose the prior is 50%, so q=50%. Then the relative entropy is DKL(30%, 50%).</p><p>But with Method 3, the uninformed tally will be 1:0 (1 upvote, 0 downvotes). The uninformed probability will thus be high. For example&rsquo;s sake, let&rsquo;s say that q=82.5%. The relative entropy is DKL(30%, 85%).</p><p>So there is a big difference in how much relative entropy we measure between Method 1 and Method 3. With Method 3, we will thus be able to see more clearly that the post actually changed minds. This will be reflected in a higher uninformed upvote probability, and thus a larger relative entropy.</p><p>In this case it will be a small difference with a lot of uncertainty. In larger groups it might be more significant.</p><h4 id=argument-for-method-1>Argument for Method 1</h4><p>In addition to simplicity, an argument for Method 1 is the idea that there isn&rsquo;t as much value in measuring relative entropy (the difference between informed and uninformed upvote probability) unless there is in fact cognitive dissonance &ndash; that is, unless there are in fact uninformed users. The relative entropy is used to score posts and send more attention to posts that are likely to change minds. But if every user is informed, there are no minds to change. So maybe Method 1 is sufficient.</p><h2 id=double-counting>Double-Counting</h2><p>An important thing to understand is that, using method 3 (and method 2), a
user can be double-counted. If 10 users vote on a post before the note is
posted, and then they all were later informed of the note, then both the
uninformed tally and the informed tally will have a sample size of 10. Even
though there are only 10 actual users.</p><p>On the other hand, it&rsquo;s possible for there to be no overlap, for example if 5
users voted on a post and were never informed of the note, and the other
fiver voted on the post only after being informed (they were never
uninformed).</p><h2 id=computing-tallies-using-triggers>Computing Tallies using Triggers</h2><p>Calculating informed/uninformed tallies is tricky because it requires either keeping track of state for each user/post/note combination. If the user changes or clears their vote on a post, we need to upvote tallies considering whether that user has considered the note. Likewise when a user changes or clears their vote on a note.</p><p>This can all be done with SQL views but these are complicated, slow, and hard to understand. Instead we use triggers, which are also complicated and hard to understand but at least much faster.</p><h2 id=solution>Solution:</h2><h3 id=votehistory-and-informedvote>VoteHistory and InformedVote</h3><p>We start with the voteHistory table, which includes every vote. The vote history includes all changes to votes and cleared votes.</p><p>The informedVote table keeps track of the latest vote for a user on a post given they have considered some note. This is updated using a trigger on inserts/updates to voteHistory.</p><h3 id=informedtally>InformedTally</h3><p>We then aggregate the votes in informedTally based on a triggers after inserts/updates to informedVote</p><h2 id=open-questions>Open Questions</h2><h3 id=adjusting-for-selection-bias-in-votes-on-note>Adjusting for Selection Bias in Votes on Note</h3><p>When we calculate $P(upvote post|voted on note)$, we introduce a voter bias. Users do decide what notes to vote on. Probably, a user who downvotes a post is more likely to vote on a note that opposes the post. However, we can adjust for this. So for example if a post has an upvoteProbability of say 90%, but of users who voted on the note, only 40% upvoted the post (60% downvoted the post), we know there is a bias (users who downvoted the post are more likely to vote on the note) and can adjust for it using a standard adjustment formula.</p><h3 id=further-todos>Further TODOS</h3><ul><li>See notes on 2024-02-06-informed-probability.md for further thoughts here. The approach proposed there requires a global estimate for P(C|not T) and P(C|T). We can estimate these if we know the slope R(C,U) for a few posts. This requires calculating P(U|not C) for some posts based on upvotes before the not was created. This would require adding a new event type to the uninformed tallies table for &ldquo;note created&rdquo;. An entry is added to this table at the moment a note is created, containing the value of the user&rsquo;s vote on the post at that time.</li></ul></div></article></main><footer class=footer><ul class=footer-links><li><a href type=application/rss+xml target=_blank>RSS</a></li><li><a href=https://github.com/social-protocols>GitHub</a></li><li><a href=https://mas.to/@SocialProtocols>Mastodon</a></li><li><a href=https://medium.com/@socialprotocols>Medium</a></li><li><a href=https://socialprotocols.substack.com>Substack</a></li><li><a href=https://twitter.com/socialprotocols>Twitter</a></li><li><a href=https://social-protocols.zulipchat.com/join/3awvls77dbmolwlradnfmkig/>Zulip</a></li></ul></footer></div><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      displayMath: [['$$','$$'], ['\\[','\\]']],
      processEscapes: true
    },
    "HTML-CSS": { fonts: ["TeX"] },
    TeX: { extensions: ["AMSmath.js", "AMSsymbols.js", "noErrors.js", "noUndefined.js"] },
    messageStyle: "none"
  });
</script><script src=/js/math-code.js></script><script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>